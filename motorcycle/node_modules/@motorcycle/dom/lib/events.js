'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeEventsSelector = undefined;

var _domEvent = require('@most/dom-event');

var _makeIsStrictlyInRootScope = require('./makeIsStrictlyInRootScope');

var matchesSelector = void 0;
try {
  matchesSelector = require('matches-selector');
} catch (e) {
  matchesSelector = function matchesSelector() {};
}

var eventTypesThatDontBubble = ['load', 'unload', 'focus', 'blur', 'mouseenter', 'mouseleave', 'submit', 'change', 'reset', 'timeupdate', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'durationchange', 'play', 'pause', 'ratechange', 'volumechange', 'suspend', 'emptied', 'stalled'];

function maybeMutateEventPropagationAttributes(event) {
  if (!event.hasOwnProperty('propagationHasBeenStopped')) {
    (function () {
      event.propagationHasBeenStopped = false;
      var oldStopPropagation = event.stopPropagation;
      event.stopPropagation = function stopPropagation() {
        oldStopPropagation.call(this);
        this.propagationHasBeenStopped = true;
      };
    })();
  }
}

function mutateEventCurrentTarget(event, currentTargetElement) {
  try {
    Object.defineProperty(event, 'currentTarget', {
      value: currentTargetElement,
      configurable: true
    });
  } catch (err) {
    console.log('please use event.ownerTarget');
  }
  event.ownerTarget = currentTargetElement;
}

function makeSimulateBubbling(namespace, rootEl) {
  var isStrictlyInRootScope = (0, _makeIsStrictlyInRootScope.makeIsStrictlyInRootScope)(namespace);
  var descendantSel = namespace.join(' ');
  var topSel = namespace.join('');
  var roof = rootEl.parentElement;

  return function simulateBubbling(ev) {
    maybeMutateEventPropagationAttributes(ev);
    if (ev.propagationHasBeenStopped) {
      return false;
    }
    for (var el = ev.target; el && el !== roof; el = el.parentElement) {
      if (!isStrictlyInRootScope(el)) {
        continue;
      }
      if (matchesSelector(el, descendantSel) || matchesSelector(el, topSel)) {
        mutateEventCurrentTarget(ev, el);
        return true;
      }
    }
    return false;
  };
}

var defaults = {
  useCapture: false
};

function makeEventsSelector(rootElement$, namespace) {
  return function eventsSelector(type) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? defaults : arguments[1];

    if (typeof type !== 'string') {
      throw new Error('DOM driver\'s events() expects argument to be a ' + 'string representing the event type to listen for.');
    }
    var useCapture = false;
    if (typeof options.useCapture === 'boolean') {
      useCapture = options.useCapture;
    }
    if (eventTypesThatDontBubble.indexOf(type) !== -1) {
      useCapture = true;
    }

    return rootElement$.map(function (rootElement) {
      return { rootElement: rootElement, namespace: namespace };
    }).skipRepeatsWith(function (prev, curr) {
      return prev.namespace.join('') === curr.namespace.join('');
    }).map(function (_ref) {
      var rootElement = _ref.rootElement;

      if (!namespace || namespace.length === 0) {
        return (0, _domEvent.domEvent)(type, rootElement, useCapture);
      }
      var simulateBubbling = makeSimulateBubbling(namespace, rootElement);
      return (0, _domEvent.domEvent)(type, rootElement, useCapture).filter(simulateBubbling);
    }).switch().multicast();
  };
}

exports.makeEventsSelector = makeEventsSelector;