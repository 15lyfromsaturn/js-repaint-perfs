'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.run = undefined;

var _mostSubject = require('most-subject');

function makeSinkProxies(drivers) {
  var sinkProxies = {};
  var keys = Object.keys(drivers);
  for (var i = 0; i < keys.length; i++) {
    sinkProxies[keys[i]] = (0, _mostSubject.holdSubject)(1);
  }
  return sinkProxies;
}

function callDrivers(drivers, sinkProxies) {
  var sources = {};
  var keys = Object.keys(drivers);
  for (var i = 0; i < keys.length; i++) {
    var name = keys[i];
    sources[name] = drivers[name](sinkProxies[name].stream, name);
  }
  return sources;
}

function makeHandleError(observer, onError) {
  return function handleError(err) {
    observer.error(err);
    onError(err);
  };
}

function replicateMany(_ref) {
  var sinks = _ref.sinks;
  var sinkProxies = _ref.sinkProxies;
  var disposableStream = _ref.disposableStream;
  var onError = _ref.onError;

  var sinkKeys = Object.keys(sinks);
  for (var i = 0; i < sinkKeys.length; i++) {
    var name = sinkKeys[i];
    if (sinkProxies.hasOwnProperty(name)) {
      var observer = sinkProxies[name].observer;

      sinks[name].until(disposableStream).observe(observer.next).then(observer.complete).catch(makeHandleError(observer, onError));
    }
  }
}

function assertSinks(sinks) {
  var keys = Object.keys(sinks);
  for (var i = 0; i < keys.length; i++) {
    if (!sinks[keys[i]] || typeof sinks[keys[i]].observe !== 'function') {
      throw new Error('Sink \'' + keys[i] + '\' must be a most.Stream');
    }
  }
  return sinks;
}

var logErrorToConsole = typeof console !== 'undefined' && console.error ? function (error) {
  console.error(error.stack || error);
} : Function.prototype;

var defaults = {
  onError: logErrorToConsole
};

function runInputGuard(_ref2) {
  var main = _ref2.main;
  var drivers = _ref2.drivers;
  var onError = _ref2.onError;

  if (typeof main !== 'function') {
    throw new Error('First argument given to run() must be the ' + '\'main\' function.');
  }
  if (typeof drivers !== 'object' || drivers === null) {
    throw new Error('Second argument given to run() must be an ' + 'object with driver functions as properties.');
  }
  if (!Object.keys(drivers).length) {
    throw new Error('Second argument given to run() must be an ' + 'object with at least one driver function declared as a property.');
  }

  if (typeof onError !== 'function') {
    throw new Error('onError must be a function');
  }
}

function run(main, drivers) {
  var _ref3 = arguments.length <= 2 || arguments[2] === undefined ? defaults : arguments[2];

  var _ref3$onError = _ref3.onError;
  var onError = _ref3$onError === undefined ? logErrorToConsole : _ref3$onError;

  runInputGuard({ main: main, drivers: drivers, onError: onError });

  var _subject = (0, _mostSubject.subject)();

  var disposableObserver = _subject.observer;
  var disposableStream = _subject.stream;

  var sinkProxies = makeSinkProxies(drivers);
  var sources = callDrivers(drivers, sinkProxies);
  var sinks = assertSinks(main(sources));
  replicateMany({ sinks: sinks, sinkProxies: sinkProxies, disposableStream: disposableStream, onError: onError });

  function dispose() {
    disposableObserver.next(1);
    disposableObserver.complete();
  }

  return { sinks: sinks, sources: sources, dispose: dispose };
}

exports.default = { run: run };
exports.run = run;